/*
 * Copyright (c) 2018 VMware, Inc. All rights reserved.
 */

package util

import (
	"time"
	"sync"
	"github.com/Sirupsen/logrus"
	"github.com/cenkalti/backoff"
)

const (
	// Random numbers generated by fair dice roll :)
	defaultInitialInterval     = 10 * time.Millisecond
	defaultRandomizationFactor = 0.5
	defaultMultiplier          = 10
	defaultMaxInterval         = 30 * time.Second
	defaultMaxElapsedTime      = 1 * time.Minute
)

type Operation func() error

// simplified config for configuring a back off object. Callers should populate and supply this to DoWithConfig
type BackoffConfig struct {
	InitialInterval     time.Duration
	RandomizationFactor float64
	Multiplier          float64
	MaxInterval         time.Duration

	// this field will indicate the maximum amount of "sleep" time that will occur.
	MaxElapsedTime 		time.Duration
	mux 				*sync.Mutex
}

// Generate a new BackoffConfig with default values
func NewBackoffConfig() *BackoffConfig {
	return &BackoffConfig{
		InitialInterval:     defaultInitialInterval,
		RandomizationFactor: defaultRandomizationFactor,
		Multiplier:          defaultMultiplier,
		MaxInterval:         defaultMaxInterval,
		MaxElapsedTime:      defaultMaxElapsedTime,
	}
}

// Generate a new BackoffConfig with default values and a lock
func NewBackoffConfigWithLock() *BackoffConfig {
	return &BackoffConfig{
		InitialInterval:     defaultInitialInterval,
		RandomizationFactor: defaultRandomizationFactor,
		Multiplier:          defaultMultiplier,
		MaxInterval:         defaultMaxInterval,
		MaxElapsedTime:      defaultMaxElapsedTime,
		mux:                 new(sync.Mutex),
	}
}

// retries the given function until defaultMaxInterval time passes, while sleeping some time between unsuccessful attempts
// if retryOnError returns true, continue retry, otherwise, return error
func Retry(operation func() error, retryOnError func(err error) bool, log logrus.FieldLogger) error {
	conf := NewBackoffConfig()
	return RetryWithConfig(operation, retryOnError, conf, log)
}

// retries the given function with lock until defaultMaxInterval time passes, while sleeping some time between unsuccessful attempts
// if retryOnError returns true, continue retry, otherwise, return error
func RetryWithLock(operation func() error, retryOnError func(err error) bool, log logrus.FieldLogger) error {
	conf := NewBackoffConfigWithLock()
	return RetryWithConfig(operation, retryOnError, conf, log)
}

// RetryWithConfig attempt an operation while retrying using an exponential back off based on the config supplied by the caller. 
// The retry decider is the supplied function retryOnError
func RetryWithConfig(operation func() error, retryOnError func(err error) bool, config *BackoffConfig, log logrus.FieldLogger) error {
	var err error
	var next time.Duration

	b := &backoff.ExponentialBackOff{
		InitialInterval:     config.InitialInterval,
		RandomizationFactor: config.RandomizationFactor,
		Multiplier:          config.Multiplier,
		MaxInterval:         config.MaxInterval,
		MaxElapsedTime:      config.MaxElapsedTime,
		Clock:               backoff.SystemClock,
	}
	// Reset the interval back to the initial retry interval and restart the timer
	b.Reset()
	for {
		if config.mux != nil {
			config.mux.Lock()
		}
		
		err = operation()
		
		if config.mux != nil {
			config.mux.Unlock()
		}

		if err == nil {
			return nil
		}

		if next = b.NextBackOff(); next == backoff.Stop {
			log.Errorf("will stop trying again. Operation failed with %s", err.Error())
			return err
		}

		// check error
		if !retryOnError(err) {
			log.Errorf("operation failed with %s\n", err.Error())
			return err
		}
		// Expected error
		log.Warnf("will try again in %s, operation failed with detected error", next)

		// sleep and try again
		time.Sleep(next)
	}
}

// OnError is the simplest of retry deciders. If an error occurs it will indicate a retry is needed.
func OnError(err error) bool {
	return err != nil
}
