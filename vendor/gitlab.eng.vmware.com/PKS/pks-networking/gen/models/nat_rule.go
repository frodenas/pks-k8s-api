// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NatRule nat rule
// swagger:model NatRule

type NatRule struct {
	ManagedResource

	// valid actions: SNAT, DNAT, NO_NAT, REFLEXIVE. All rules in a logical
	// router are either stateless or stateful. Mix is not supported.
	// SNAT and DNAT are stateful, can NOT be supported when the logical router is
	// running at active-active HA mode; REFLEXIVE is stateless. NO_NAT has no
	// translated_fields, only match fields.
	//
	// Required: true
	Action *string `json:"action"`

	// enable/disable the rule
	//
	// enable/disable the rule
	Enabled *bool `json:"enabled,omitempty"`

	// enable/disable the logging of rule
	//
	// enable/disable the logging of rule
	Logging *bool `json:"logging,omitempty"`

	// Logical router id
	//
	// Logical router id
	// Read Only: true
	LogicalRouterID string `json:"logical_router_id,omitempty"`

	// match destination network
	//
	// IP Address | CIDR | (null implies Any)
	//
	MatchDestinationNetwork string `json:"match_destination_network,omitempty"`

	// match source network
	//
	// IP Address | CIDR | (null implies Any)
	//
	MatchSourceNetwork string `json:"match_source_network,omitempty"`

	// enable/disable to bypass following firewall stage
	//
	// Default is true. If the nat_pass is set to true, the following firewall
	// stage will be skipped. Please note, if action is NO_NAT, then nat_pass
	// must be set to true or omitted.
	//
	NatPass *bool `json:"nat_pass,omitempty"`

	// NAT rule priority
	//
	// Ascending, valid range [0-2147483647]. If multiple rules have the same
	// priority, evaluation sequence is undefined.
	//
	RulePriority *int64 `json:"rule_priority,omitempty"`

	// IP Address | IP Range | CIDR
	//
	// IP Address | IP Range | CIDR
	TranslatedNetwork string `json:"translated_network,omitempty"`

	// port number or port range. DNAT only
	//
	// port number or port range. DNAT only
	TranslatedPorts string `json:"translated_ports,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *NatRule) UnmarshalJSON(raw []byte) error {

	var aO0 ManagedResource
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.ManagedResource = aO0

	var data struct {
		Action *string `json:"action"`

		Enabled *bool `json:"enabled,omitempty"`

		Logging *bool `json:"logging,omitempty"`

		LogicalRouterID string `json:"logical_router_id,omitempty"`

		MatchDestinationNetwork string `json:"match_destination_network,omitempty"`

		MatchSourceNetwork string `json:"match_source_network,omitempty"`

		NatPass *bool `json:"nat_pass,omitempty"`

		RulePriority *int64 `json:"rule_priority,omitempty"`

		TranslatedNetwork string `json:"translated_network,omitempty"`

		TranslatedPorts string `json:"translated_ports,omitempty"`
	}
	if err := swag.ReadJSON(raw, &data); err != nil {
		return err
	}

	m.Action = data.Action

	m.Enabled = data.Enabled

	m.Logging = data.Logging

	m.LogicalRouterID = data.LogicalRouterID

	m.MatchDestinationNetwork = data.MatchDestinationNetwork

	m.MatchSourceNetwork = data.MatchSourceNetwork

	m.NatPass = data.NatPass

	m.RulePriority = data.RulePriority

	m.TranslatedNetwork = data.TranslatedNetwork

	m.TranslatedPorts = data.TranslatedPorts

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m NatRule) MarshalJSON() ([]byte, error) {
	var _parts [][]byte

	aO0, err := swag.WriteJSON(m.ManagedResource)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	var data struct {
		Action *string `json:"action"`

		Enabled *bool `json:"enabled,omitempty"`

		Logging *bool `json:"logging,omitempty"`

		LogicalRouterID string `json:"logical_router_id,omitempty"`

		MatchDestinationNetwork string `json:"match_destination_network,omitempty"`

		MatchSourceNetwork string `json:"match_source_network,omitempty"`

		NatPass *bool `json:"nat_pass,omitempty"`

		RulePriority *int64 `json:"rule_priority,omitempty"`

		TranslatedNetwork string `json:"translated_network,omitempty"`

		TranslatedPorts string `json:"translated_ports,omitempty"`
	}

	data.Action = m.Action

	data.Enabled = m.Enabled

	data.Logging = m.Logging

	data.LogicalRouterID = m.LogicalRouterID

	data.MatchDestinationNetwork = m.MatchDestinationNetwork

	data.MatchSourceNetwork = m.MatchSourceNetwork

	data.NatPass = m.NatPass

	data.RulePriority = m.RulePriority

	data.TranslatedNetwork = m.TranslatedNetwork

	data.TranslatedPorts = m.TranslatedPorts

	jsonData, err := swag.WriteJSON(data)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, jsonData)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this nat rule
func (m *NatRule) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.ManagedResource.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var natRuleTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SNAT","DNAT","NO_NAT","REFLEXIVE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		natRuleTypeActionPropEnum = append(natRuleTypeActionPropEnum, v)
	}
}

// property enum
func (m *NatRule) validateActionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, natRuleTypeActionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *NatRule) validateAction(formats strfmt.Registry) error {

	if err := validate.Required("action", "body", m.Action); err != nil {
		return err
	}

	// value enum
	if err := m.validateActionEnum("action", "body", *m.Action); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NatRule) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NatRule) UnmarshalBinary(b []byte) error {
	var res NatRule
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
