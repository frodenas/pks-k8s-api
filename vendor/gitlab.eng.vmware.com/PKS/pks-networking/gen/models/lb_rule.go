// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LbRule Load balancer rules
//
// Load balancer rules allow customization of load balancing behavior using
// match/action rules. Currently, load balancer rules are supported for only
// layer 7 virtual servers with application profile LbHttpProfile.
// Each application rule consists of one or more match conditions and one or
// more actions.
// Load balancer rules could be used by different load balancer services.
//
// swagger:model LbRule

type LbRule struct {
	ManagedResource

	// Actions to be executed
	//
	// A list of actions to be executed at specified phase when load balancer
	// rule matches. The actions are used to manipulate application traffic,
	// such as rewrite URI of HTTP messages, redirect HTTP messages, etc.
	//
	// Required: true
	// Max Items: 60
	Actions []*LbRuleAction `json:"actions"`

	// Conditions to match application traffic
	//
	// A list of match conditions used to match application traffic. Multiple
	// match conditions can be specified in one load balancer rule, each match
	// condition defines a criterion to match application traffic.
	// If no match conditions are specified, then the load balancer rule will
	// always match and it is used typically to define default rules. If more
	// than one match condition is specified, then match strategy determines
	// if all conditions should match or any one condition should match for the
	// load balancer rule to considered a match.
	//
	// Max Items: 60
	MatchConditions []*LbRuleCondition `json:"match_conditions"`

	// Strategy to match multiple conditions
	//
	// Strategy to define how load balancer rule is considered a match when
	// multiple match conditions are specified in one rule. If match_stragety
	// is set to ALL, then load balancer rule is considered a match only if all
	// the conditions match. If match_strategy is set to ANY, then load
	// balancer rule is considered a match if any one of the conditions match.
	//
	// Required: true
	MatchStrategy *string `json:"match_strategy"`

	// Load balancer processing phase
	//
	// Each load balancer rule is used at a specific phase of load balancer
	// processing. Currently three phases are supported, HTTP_REQUEST_REWRITE,
	// HTTP_FORWARDING and HTTP_RESPONSE_REWRITE.
	// When an HTTP request message is received by load balancer, all
	// HTTP_REQUEST_REWRITE rules, if present are executed in the order they
	// are applied to virtual server. And then if HTTP_FORWARDING rules
	// present, only first matching rule's action is executed, remaining rules
	// are not checked. HTTP_FORWARDING rules can have only one action. If the
	// request is forwarded to a backend server and the response goes back to
	// load balancer, all HTTP_RESPONSE_REWRITE rules, if present, are executed
	// in the order they are applied to the virtual server.
	//
	// Required: true
	Phase *string `json:"phase"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *LbRule) UnmarshalJSON(raw []byte) error {

	var aO0 ManagedResource
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.ManagedResource = aO0

	var data struct {
		Actions []*LbRuleAction `json:"actions"`

		MatchConditions []*LbRuleCondition `json:"match_conditions,omitempty"`

		MatchStrategy *string `json:"match_strategy"`

		Phase *string `json:"phase"`
	}
	if err := swag.ReadJSON(raw, &data); err != nil {
		return err
	}

	m.Actions = data.Actions

	m.MatchConditions = data.MatchConditions

	m.MatchStrategy = data.MatchStrategy

	m.Phase = data.Phase

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m LbRule) MarshalJSON() ([]byte, error) {
	var _parts [][]byte

	aO0, err := swag.WriteJSON(m.ManagedResource)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	var data struct {
		Actions []*LbRuleAction `json:"actions"`

		MatchConditions []*LbRuleCondition `json:"match_conditions,omitempty"`

		MatchStrategy *string `json:"match_strategy"`

		Phase *string `json:"phase"`
	}

	data.Actions = m.Actions

	data.MatchConditions = m.MatchConditions

	data.MatchStrategy = m.MatchStrategy

	data.Phase = m.Phase

	jsonData, err := swag.WriteJSON(data)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, jsonData)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this lb rule
func (m *LbRule) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.ManagedResource.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateActions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMatchConditions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMatchStrategy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhase(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LbRule) validateActions(formats strfmt.Registry) error {

	if err := validate.Required("actions", "body", m.Actions); err != nil {
		return err
	}

	iActionsSize := int64(len(m.Actions))

	if err := validate.MaxItems("actions", "body", iActionsSize, 60); err != nil {
		return err
	}

	for i := 0; i < len(m.Actions); i++ {

		if swag.IsZero(m.Actions[i]) { // not required
			continue
		}

		if m.Actions[i] != nil {

			if err := m.Actions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("actions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LbRule) validateMatchConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.MatchConditions) { // not required
		return nil
	}

	iMatchConditionsSize := int64(len(m.MatchConditions))

	if err := validate.MaxItems("match_conditions", "body", iMatchConditionsSize, 60); err != nil {
		return err
	}

	for i := 0; i < len(m.MatchConditions); i++ {

		if swag.IsZero(m.MatchConditions[i]) { // not required
			continue
		}

		if m.MatchConditions[i] != nil {

			if err := m.MatchConditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("match_conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var lbRuleTypeMatchStrategyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ALL","ANY"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lbRuleTypeMatchStrategyPropEnum = append(lbRuleTypeMatchStrategyPropEnum, v)
	}
}

// property enum
func (m *LbRule) validateMatchStrategyEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, lbRuleTypeMatchStrategyPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *LbRule) validateMatchStrategy(formats strfmt.Registry) error {

	if err := validate.Required("match_strategy", "body", m.MatchStrategy); err != nil {
		return err
	}

	// value enum
	if err := m.validateMatchStrategyEnum("match_strategy", "body", *m.MatchStrategy); err != nil {
		return err
	}

	return nil
}

var lbRuleTypePhasePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["HTTP_REQUEST_REWRITE","HTTP_FORWARDING","HTTP_RESPONSE_REWRITE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lbRuleTypePhasePropEnum = append(lbRuleTypePhasePropEnum, v)
	}
}

// property enum
func (m *LbRule) validatePhaseEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, lbRuleTypePhasePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *LbRule) validatePhase(formats strfmt.Registry) error {

	if err := validate.Required("phase", "body", m.Phase); err != nil {
		return err
	}

	// value enum
	if err := m.validatePhaseEnum("phase", "body", *m.Phase); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LbRule) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LbRule) UnmarshalBinary(b []byte) error {
	var res LbRule
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
