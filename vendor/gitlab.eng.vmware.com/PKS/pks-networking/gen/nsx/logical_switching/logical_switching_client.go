// Code generated by go-swagger; DO NOT EDIT.

package logical_switching

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new logical switching API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for logical switching API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
CreateLogicalPort creates a logical port

Creates a new logical switch port. The required parameters are the
associated logical_switch_id and admin_state (UP or DOWN). Optional
parameters are the attachment and switching_profile_ids. If you don't
specify switching_profile_ids, default switching profiles are assigned to
the port. If you don't specify an attachment, the switch port remains
empty. To configure an attachment, you must specify an id, and
optionally you can specify an attachment_type (VIF or LOGICALROUTER).
The attachment_type is VIF by default.

*/
func (a *Client) CreateLogicalPort(params *CreateLogicalPortParams, authInfo runtime.ClientAuthInfoWriter) (*CreateLogicalPortCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateLogicalPortParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateLogicalPort",
		Method:             "POST",
		PathPattern:        "/logical-ports",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateLogicalPortReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateLogicalPortCreated), nil

}

/*
CreateLogicalSwitch creates a logical switch

Creates a new logical switch. The request must include the
transport_zone_id, display_name, and admin_state (UP or DOWN). The
replication_mode (MTEP or SOURCE) is required for overlay logical
switches, but not for VLAN-based logical switches. A vlan needs to be
provided for VLAN-based logical switches

*/
func (a *Client) CreateLogicalSwitch(params *CreateLogicalSwitchParams, authInfo runtime.ClientAuthInfoWriter) (*CreateLogicalSwitchCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateLogicalSwitchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateLogicalSwitch",
		Method:             "POST",
		PathPattern:        "/logical-switches",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateLogicalSwitchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateLogicalSwitchCreated), nil

}

/*
CreateSwitchingProfile creates a switching profile

Creates a new, custom qos, port-mirroring, spoof-guard or port-security
switching profile. You can override their default switching profile assignments
by creating a new switching profile and assigning it to one or more logical
switches. You cannot override the default ipfix or ip_discovery switching profiles.

*/
func (a *Client) CreateSwitchingProfile(params *CreateSwitchingProfileParams, authInfo runtime.ClientAuthInfoWriter) (*CreateSwitchingProfileCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateSwitchingProfileParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateSwitchingProfile",
		Method:             "POST",
		PathPattern:        "/switching-profiles",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateSwitchingProfileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateSwitchingProfileCreated), nil

}

/*
DeleteLogicalPort deletes a logical port

Deletes the specified logical switch port. By default, if logical port has
attachments, or it is added to any NSGroup, the deletion will be failed.
Option detach could be used for deleting logical port forcibly.

*/
func (a *Client) DeleteLogicalPort(params *DeleteLogicalPortParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteLogicalPortOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteLogicalPortParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteLogicalPort",
		Method:             "DELETE",
		PathPattern:        "/logical-ports/{lport-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteLogicalPortReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteLogicalPortOK), nil

}

/*
DeleteLogicalSwitch deletes a logical switch

Removes a logical switch from the associated overlay or VLAN transport
zone. By default, a logical switch cannot be deleted if there are logical
ports on the switch, or it is added to a NSGroup.
Cascade option can be used to delete all ports and the logical switch.
Detach option can be used to delete the logical switch forcibly.

*/
func (a *Client) DeleteLogicalSwitch(params *DeleteLogicalSwitchParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteLogicalSwitchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteLogicalSwitchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteLogicalSwitch",
		Method:             "DELETE",
		PathPattern:        "/logical-switches/{lswitch-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteLogicalSwitchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteLogicalSwitchOK), nil

}

/*
DeleteSwitchingProfile deletes a switching profile

Deletes the specified switching profile.
*/
func (a *Client) DeleteSwitchingProfile(params *DeleteSwitchingProfileParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteSwitchingProfileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteSwitchingProfileParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteSwitchingProfile",
		Method:             "DELETE",
		PathPattern:        "/switching-profiles/{switching-profile-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteSwitchingProfileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteSwitchingProfileOK), nil

}

/*
GetLogicalPort gets information about a logical port

Returns information about a specified logical port.
*/
func (a *Client) GetLogicalPort(params *GetLogicalPortParams, authInfo runtime.ClientAuthInfoWriter) (*GetLogicalPortOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLogicalPortParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetLogicalPort",
		Method:             "GET",
		PathPattern:        "/logical-ports/{lport-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetLogicalPortReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetLogicalPortOK), nil

}

/*
GetLogicalSwitch gets logical switch associated with the provided lswitch id

Returns information about the specified logical switch Id.
*/
func (a *Client) GetLogicalSwitch(params *GetLogicalSwitchParams, authInfo runtime.ClientAuthInfoWriter) (*GetLogicalSwitchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLogicalSwitchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetLogicalSwitch",
		Method:             "GET",
		PathPattern:        "/logical-switches/{lswitch-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetLogicalSwitchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetLogicalSwitchOK), nil

}

/*
ListLogicalPorts lists all logical ports

Returns information about all configured logical switch ports. Logical
switch ports connect to VM virtual network interface cards (NICs). Each
logical port is associated with one logical switch.

*/
func (a *Client) ListLogicalPorts(params *ListLogicalPortsParams, authInfo runtime.ClientAuthInfoWriter) (*ListLogicalPortsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListLogicalPortsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListLogicalPorts",
		Method:             "GET",
		PathPattern:        "/logical-ports",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListLogicalPortsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListLogicalPortsOK), nil

}

/*
ListLogicalSwitches lists all logical switches

Returns information about all configured logical switches.
*/
func (a *Client) ListLogicalSwitches(params *ListLogicalSwitchesParams, authInfo runtime.ClientAuthInfoWriter) (*ListLogicalSwitchesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListLogicalSwitchesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListLogicalSwitches",
		Method:             "GET",
		PathPattern:        "/logical-switches",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListLogicalSwitchesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListLogicalSwitchesOK), nil

}

/*
ListSwitchingProfiles lists switching profiles

Returns information about the system-default and user-configured switching
profiles. Each switching profile has a unique ID, a display name, and
various other read-only and configurable properties. The default switching
profiles are assigned automatically to each switch.

*/
func (a *Client) ListSwitchingProfiles(params *ListSwitchingProfilesParams, authInfo runtime.ClientAuthInfoWriter) (*ListSwitchingProfilesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListSwitchingProfilesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListSwitchingProfiles",
		Method:             "GET",
		PathPattern:        "/switching-profiles",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListSwitchingProfilesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListSwitchingProfilesOK), nil

}

/*
UpdateLogicalSwitch updates a logical switch

Modifies attributes of an existing logical switch. Modifiable
attributes include admin_state, replication_mode, switching_profile_ids
and vlan. You cannot modify the original transport_zone_id.

*/
func (a *Client) UpdateLogicalSwitch(params *UpdateLogicalSwitchParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateLogicalSwitchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateLogicalSwitchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateLogicalSwitch",
		Method:             "PUT",
		PathPattern:        "/logical-switches/{lswitch-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateLogicalSwitchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateLogicalSwitchOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
