// Code generated by go-swagger; DO NOT EDIT.

package grouping_objects

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new grouping objects API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for grouping objects API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
CreateNSGroup creates n s group

Creates a new NSGroup that can group NSX resources - VIFs, Lports
and LSwitches as well as the grouping objects - IPSet, MACSet and other
NSGroups

*/
func (a *Client) CreateNSGroup(params *CreateNSGroupParams, authInfo runtime.ClientAuthInfoWriter) (*CreateNSGroupCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateNSGroupParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateNSGroup",
		Method:             "POST",
		PathPattern:        "/ns-groups",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateNSGroupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateNSGroupCreated), nil

}

/*
DeleteIPSet deletes IP set

Deletes the specified IPSet.  By default, if the IPSet is added to an
NSGroup, it won't be deleted. In such situations, pass "force=true" as
query param to force delete the IPSet.

*/
func (a *Client) DeleteIPSet(params *DeleteIPSetParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteIPSetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteIPSetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteIPSet",
		Method:             "DELETE",
		PathPattern:        "/ip-sets/{ip-set-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteIPSetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteIPSetOK), nil

}

/*
DeleteNSGroup deletes n s group

Deletes the specified NSGroup. By default, if the NSGroup is added to
another NSGroup, it won't be deleted. In such situations, pass
"force=true" as query param to force delete the NSGroup.

*/
func (a *Client) DeleteNSGroup(params *DeleteNSGroupParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteNSGroupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteNSGroupParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteNSGroup",
		Method:             "DELETE",
		PathPattern:        "/ns-groups/{ns-group-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteNSGroupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteNSGroupOK), nil

}

/*
ListIPSets lists IP sets

Returns paginated list of IPSets

*/
func (a *Client) ListIPSets(params *ListIPSetsParams, authInfo runtime.ClientAuthInfoWriter) (*ListIPSetsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListIPSetsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListIPSets",
		Method:             "GET",
		PathPattern:        "/ip-sets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListIPSetsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListIPSetsOK), nil

}

/*
ListNSGroups lists n s groups

List the NSGroups in a paginated format. The page size is restricted
to 50 NSGroups so that the size of the response remains small even
in the worst case.
Optionally, specify valid member types as request parameter to filter NSGroups.

*/
func (a *Client) ListNSGroups(params *ListNSGroupsParams, authInfo runtime.ClientAuthInfoWriter) (*ListNSGroupsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListNSGroupsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListNSGroups",
		Method:             "GET",
		PathPattern:        "/ns-groups",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListNSGroupsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListNSGroupsOK), nil

}

/*
ReadNSGroup reads n s group

Returns information about the specified NSGroup.

*/
func (a *Client) ReadNSGroup(params *ReadNSGroupParams, authInfo runtime.ClientAuthInfoWriter) (*ReadNSGroupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReadNSGroupParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ReadNSGroup",
		Method:             "GET",
		PathPattern:        "/ns-groups/{ns-group-id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ReadNSGroupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ReadNSGroupOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
